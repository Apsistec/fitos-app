"""AI Coach endpoints - multi-agent coaching conversations"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Any
import logging

from app.agents import build_coach_graph, ChatMessage, UserContext, ChatAction

logger = logging.getLogger("fitos-ai")
router = APIRouter()

# Build graph once at startup
coach_graph = build_coach_graph()


class ChatRequest(BaseModel):
    """Chat request payload"""
    message: str
    conversationHistory: List[ChatMessage] = []
    userContext: UserContext


class ChatResponse(BaseModel):
    """Chat response payload"""
    message: str
    agentSource: str
    actions: List[ChatAction] | None = None
    shouldEscalate: bool = False


@router.post("/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """
    Multi-agent coaching conversation endpoint.

    Handles:
    - Workout programming questions
    - Nutrition guidance (adherence-neutral)
    - Recovery and HRV interpretation
    - Motivation and accountability
    - Escalation to human trainer when needed

    Example Request:
    ```json
    {
      "message": "How much protein should I eat?",
      "conversationHistory": [],
      "userContext": {
        "user_id": "uuid",
        "role": "client",
        "goals": ["muscle_gain"],
        "fitness_level": "intermediate"
      }
    }
    ```
    """
    try:
        logger.info(f"Processing chat for user {request.userContext.user_id}: {request.message[:50]}...")

        # Prepare state
        initial_state = {
            "message": request.message,
            "user_context": request.userContext,
            "conversation_history": request.conversationHistory,
            "current_agent": None,
            "should_escalate": False,
            "response": None,
            "agent_source": None,
            "suggested_actions": [],
            "confidence": 0.0,
            "iterations": 0,
        }

        # Run through agent graph
        result = await coach_graph.ainvoke(initial_state)

        # Build response
        response = ChatResponse(
            message=result["response"] or "I'm having trouble processing that. Could you rephrase?",
            agentSource=result["agent_source"] or "general",
            actions=result.get("suggested_actions"),
            shouldEscalate=result.get("should_escalate", False)
        )

        logger.info(f"Response generated by {response.agentSource} agent")

        return response

    except Exception as e:
        logger.error(f"Error in chat endpoint: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to process chat message")


@router.post("/action")
async def execute_action(action: ChatAction):
    """
    Execute a suggested action from the AI coach.

    Actions include:
    - log_workout: Redirect user to workout logging
    - adjust_program: Modify training program
    - set_reminder: Create a notification
    - escalate_trainer: Notify trainer
    """
    try:
        logger.info(f"Executing action: {action.type}")

        # In a real implementation, this would:
        # 1. Validate the action
        # 2. Make changes to database
        # 3. Send notifications
        # 4. Return success/failure

        # For now, just acknowledge
        return {
            "success": True,
            "action": action.type,
            "message": f"Action {action.type} executed successfully"
        }

    except Exception as e:
        logger.error(f"Error executing action: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to execute action")
